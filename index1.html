<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>River Boat Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
        }
        canvas {
            border: 1px solid #000;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="800"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Asset paths (make sure these are accessible from your HTML file)
        const assetPaths = {
            sounds: {
                bgm: 'assets/sounds/bgm.ogg',
                coinS: 'assets/sounds/coinS.ogg',
                gmover: 'assets/sounds/gmover.ogg'
            },
            images: {
                river1: "assets/images/river1.png",
                river2: "assets/images/river2.png",
                river3: "assets/images/river3.png",
                river4: "assets/images/river4.png",
                river5: "assets/images/river5.png",
                river6: "assets/images/river6.png",
                boat: "assets/images/boat1.png",
                wood1: "assets/images/wood1.png",
                wood2: "assets/images/wood2.png",
                wood3: "assets/images/wood3.png"
            }
        };

        // Load assets
        const assets = {
            sounds: {},
            images: {}
        };

        let assetsLoaded = 0;
        const totalAssets = Object.keys(assetPaths.sounds).length + Object.keys(assetPaths.images).length;

        function assetLoaded() {
            assetsLoaded++;
            if (assetsLoaded === totalAssets) {
                // All assets are loaded, start the game loop
                requestAnimationFrame(gameLoop);
            }
        }

        // Pre-load sounds
        for (const key in assetPaths.sounds) {
            assets.sounds[key] = new Audio(assetPaths.sounds[key]);
            assets.sounds[key].addEventListener('canplaythrough', assetLoaded, { once: true });
        }

        // Pre-load images
        for (const key in assetPaths.images) {
            assets.images[key] = new Image();
            assets.images[key].src = assetPaths.images[key];
            assets.images[key].onload = assetLoaded;
            assets.images[key].onerror = () => {
                console.error(`Failed to load image: ${assetPaths.images[key]}`);
                // Draw a placeholder if image fails to load
                const placeholderCanvas = document.createElement('canvas');
                const placeholderCtx = placeholderCanvas.getContext('2d');
                placeholderCanvas.width = 64;
                placeholderCanvas.height = 64;
                placeholderCtx.fillStyle = 'red';
                placeholderCtx.fillRect(0, 0, 64, 64);
                assets.images[key].src = placeholderCanvas.toDataURL();
            };
        }


        let river_speed = 0;
        function riverXY(x, y, river_speed) {
            if (river_speed >= 0 && river_speed <= 50) {
                ctx.drawImage(assets.images.river1, x, y);
            } else if (river_speed >= 51 && river_speed <= 100) {
                ctx.drawImage(assets.images.river2, x, y);
            } else if (river_speed >= 101 && river_speed <= 150) {
                ctx.drawImage(assets.images.river3, x, y);
            } else if (river_speed >= 151 && river_speed <= 200) {
                ctx.drawImage(assets.images.river4, x, y);
            } else if (river_speed >= 201 && river_speed <= 250) {
                ctx.drawImage(assets.images.river5, x, y);
            } else {
                ctx.drawImage(assets.images.river6, x, y);
            }
        }

        let boat_x = 300;
        let boat_y = 520;
        let boat_xChange = 0;

        function boatXY(x, y) {
            ctx.drawImage(assets.images.boat, x, y);
        }

        // Floating wood
        let wood1_x = 170;
        let wood1_y = -50;
        let wood2_x = 320;
        let wood2_y = -200;
        let wood3_x = 350;
        let wood3_y = -350;
        let wood4_x = 220;
        let wood4_y = -480;
        let wood5_x = 190;
        let wood5_y = -630;
        let wood_speed = 2; //boat speed change

        function woodXY(x, y, wood_img) {
            ctx.drawImage(wood_img, x, y);
        }

        // User interface
        let gameStart = false;
        const button_start = { x: 200, y: 690, width: 250, height: 80 };
        const button_pad = { x: 0, y: 650, width: 600, height: 150 };
        const button_left = { x: 20, y: 660, width: 120, height: 120 };
        const button_right = { x: 460, y: 660, width: 120, height: 120 };

        function draw_start_button() {
            ctx.fillStyle = 'rgb(10, 200, 10)';
            ctx.beginPath();
            ctx.roundRect(button_start.x, button_start.y, button_start.width, button_start.height, [20]);
            ctx.fill();
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = '40px sans-serif';
            ctx.fillText("START", button_start.x + 50, button_start.y + 50);
        }

        function draw_button_pad() {
            ctx.fillStyle = 'rgb(200, 150, 200)';
            ctx.fillRect(button_pad.x, button_pad.y, button_pad.width, button_pad.height);
        }

        function draw_buttons() {
            ctx.fillStyle = 'rgb(100, 100, 100)';
            ctx.beginPath();
            ctx.roundRect(button_left.x, button_left.y, button_left.width, button_left.height, [20]);
            ctx.fill();
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = '40px sans-serif';
            ctx.fillText("<<", button_left.x + 30, button_left.y + 75);

            ctx.fillStyle = 'rgb(100, 100, 100)';
            ctx.beginPath();
            ctx.roundRect(button_right.x, button_right.y, button_right.width, button_right.height, [20]);
            ctx.fill();
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.font = '40px sans-serif';
            ctx.fillText(">>", button_right.x + 30, button_right.y + 75);
        }

        // On-screen keyboard
        const keys_rows = [
            ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
            ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
            ["Z", "X", "C", "V", "B", "N", "M", "DEL", "ENT"]
        ];

        const key_buttons = [];
        const key_width = 55;
        const key_height = 60;
        const padding = 5;
        const start_x = 5;
        const start_y = 450;

        keys_rows.forEach((row, row_idx) => {
            row.forEach((k, col_idx) => {
                const rect = {
                    key: k,
                    x: start_x + col_idx * (key_width + padding),
                    y: start_y + row_idx * (key_height + padding),
                    width: k.length > 1 ? key_width * 1.5 : key_width,
                    height: key_height
                };
                key_buttons.push(rect);
            });
        });

        // Name box
        const input_box = { x: 150, y: 350, width: 400, height: 60 };
        let player_name = "";

        // Game over text
        function gameXY(x, y) {
            ctx.font = 'bold 80px sans-serif';
            ctx.fillStyle = 'rgb(110, 0, 0)';
            ctx.fillText('GAME OVER', x, y);
        }

        let score_value = 0;
        function scoreXY(x, y, score_value, player_name) {
            ctx.font = 'bold 24px sans-serif';
            ctx.fillStyle = 'rgb(100, 0, 100)';
            ctx.fillText('SCORE: ' + score_value, x, y);
            ctx.fillText('Player: ' + player_name, x - 100, y + 45);
        }

        // Score save in Firebase
        let save_name_score = false;
        const FIREBASE_URL = "https://bambooblitz-413ec-default-rtdb.asia-southeast1.firebasedatabase.app/rivergame.json";

        async function save_score(player_name, score_value) {
            const data = {
                "name": player_name,
                "score": score_value
            };
            try {
                const response = await fetch(FIREBASE_URL, {
                    method: 'POST',
                    body: JSON.stringify(data),
                    headers: { 'Content-Type': 'application/json' }
                });
                if (response.ok) {
                    console.log("Score saved successfully!");
                } else {
                    console.error("Error saving score:", await response.text());
                }
            } catch (error) {
                console.error("Network error:", error);
            }
        }

        let topScores = [];
        async function get_top_scores() {
             try {
                const response = await fetch(FIREBASE_URL);
                if (response.ok) {
                    const data = await response.json();
                    if (!data) {
                        topScores = [];
                        return;
                    }
                    const scores = Object.values(data);
                    topScores = scores.sort((a, b) => b.score - a.score).slice(0, 10);
                } else {
                    console.error("Error fetching scores:", await response.text());
                    topScores = [];
                }
            } catch (error) {
                console.error("Network error fetching scores:", error);
                topScores = [];
            }
        }

        function get_rank_str(index) {
            if (index === 0) return "1st";
            if (index === 1) return "2nd";
            if (index === 2) return "3rd";
            return `${index + 1}th`;
        }

        let gameOver = false;
        let running = true;
        let background_music_start = false;
        let gameOver_music = false;

        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        // --- Event Listeners ---
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isInside(pos, rect) {
            return pos.x > rect.x && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height && pos.y > rect.y;
        }

        canvas.addEventListener('mousedown', async (e) => {
            const mousePos = getMousePos(canvas, e);

            if (isInside(mousePos, button_start) && !gameStart) {
                if (player_name.trim() !== "") {
                    gameStart = true;
                    assets.sounds.coinS.currentTime = 0;
                    assets.sounds.coinS.play();
                }
            }

            if (gameStart) {
                if (isInside(mousePos, button_right) && boat_x <= 523) {
                    assets.sounds.coinS.currentTime = 0;
                    assets.sounds.coinS.play();
                    boat_xChange = 4;
                }
                if (isInside(mousePos, button_left) && boat_x >= 121) {
                    assets.sounds.coinS.currentTime = 0;
                    assets.sounds.coinS.play();
                    boat_xChange = -4;
                }
            } else { // Name entry screen
                for (const keyRect of key_buttons) {
                    if (isInside(mousePos, keyRect)) {
                        if (keyRect.key === "DEL") {
                            player_name = player_name.slice(0, -1);
                        } else if (keyRect.key === "ENT") {
                            if (player_name.trim() !== "") {
                                gameStart = true;
                            }
                        } else {
                            if (player_name.length < 16) {
                                player_name += keyRect.key;
                            }
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            boat_xChange = 0;
        });

        // --- Main Game Loop ---
        function gameLoop() {
            // Clear screen
            ctx.fillStyle = 'rgb(255, 255, 255)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Game logic updates
            if (gameStart && !gameOver) {
                if (!background_music_start) {
                    assets.sounds.bgm.loop = true;
                    assets.sounds.bgm.volume = 0.3;
                    assets.sounds.bgm.play();
                    background_music_start = true;
                }
                river_speed += 5;
            }
            if (river_speed >= 300) {
                river_speed = 0;
            }

            // Drawing river
            riverXY(0, 0, river_speed);

            // Woods floating after game start
            if (gameStart && !gameOver) {
                wood1_y += wood_speed;
                if (wood1_y >= 710) {
                    wood1_x = 390 - (Math.floor(Math.random() * 7) * 30);
                    wood1_y = -80 - (Math.floor(Math.random() * 5) * 5);
                    score_value += 1;
                }
                wood2_y += wood_speed;
                if (wood2_y >= 720) {
                    wood2_x = 170 + (Math.floor(Math.random() * 4) * 40);
                    wood2_y = -80 - (Math.floor(Math.random() * 5) * 5);
                    score_value += 1;
                }
                wood3_y += wood_speed;
                if (wood3_y >= 730) {
                    wood3_x = 390 - (20 + Math.floor(Math.random() * 11) * 20);
                    wood3_y = -80 - (Math.floor(Math.random() * 3) * 10);
                    score_value += 1;
                }
                wood4_y += wood_speed;
                if (wood4_y >= 740) {
                    wood4_x = 210 + (Math.floor(Math.random() * 7) * 20);
                    wood4_y = -80 - (Math.floor(Math.random() * 5) * 5);
                    score_value += 1;
                }
                wood5_y += wood_speed;
                if (wood5_y >= 750) {
                    wood5_x = 250 + (Math.floor(Math.random() * 5) * 20);
                    wood5_y = -80 - (Math.floor(Math.random() * 5) * 5);
                    score_value += 1;
                }

                let lastSpeedIncreaseScore = 0;

                if (score_value - lastSpeedIncreaseScore >= 20) {
                wood_speed = 2 + (Math.floor(score_value / 20) * 0.5);
                lastSpeedIncreaseScore = score_value - (score_value % 20); // update threshold
                    }

            }

            woodXY(wood1_x, wood1_y, assets.images.wood1);
            woodXY(wood2_x, wood2_y, assets.images.wood2);
            woodXY(wood3_x, wood3_y, assets.images.wood3);
            woodXY(wood4_x, wood4_y, assets.images.wood2);
            woodXY(wood5_x, wood5_y, assets.images.wood3);

            // Boat control
            if (!gameOver) {
                boat_x += boat_xChange;
            }
            if (boat_x <= 170) boat_x = 170;
            if (boat_x >= 400) boat_x = 400;

            boatXY(boat_x, boat_y);

            // Collision check
            const boat_rect = { x: boat_x + 10, y: boat_y + 35, width: assets.images.boat.width - 10, height: assets.images.boat.height - 25 };
            const wood1_rect = { x: wood1_x + 4, y: wood1_y + 5, width: assets.images.wood1.width - 10, height: assets.images.wood1.height - 7 };
            const wood2_rect = { x: wood2_x, y: wood2_y + 9, width: assets.images.wood2.width - 4, height: assets.images.wood2.height - 10 };
            const wood3_rect = { x: wood3_x + 12, y: wood3_y + 10, width: assets.images.wood3.width - 13, height: assets.images.wood3.height - 6 };
            const wood4_rect = { x: wood4_x, y: wood4_y + 9, width: assets.images.wood2.width - 4, height: assets.images.wood2.height - 10 };
            const wood5_rect = { x: wood5_x + 12, y: wood5_y + 10, width: assets.images.wood3.width - 13, height: assets.images.wood3.height - 6 };

            if (!gameOver && (checkCollision(boat_rect, wood1_rect) ||
                checkCollision(boat_rect, wood2_rect) ||
                checkCollision(boat_rect, wood3_rect) ||
                checkCollision(boat_rect, wood4_rect) ||
                checkCollision(boat_rect, wood5_rect))) {
                gameOver = true;
                if (!gameOver_music) {
                    assets.sounds.bgm.pause();
                    assets.sounds.gmover.play();
                    gameOver_music = true;
                }
            }

            // Game Over Screen
            if (gameOver) {
                gameXY(80, 170);
                if (!save_name_score) {
                    save_name_score = true; // Set flag immediately to prevent multiple saves
                    // Use an async IIFE to ensure score is saved before fetching leaderboard
                    (async () => {
                        await save_score(player_name, score_value);
                        await get_top_scores(); // Fetch scores *after* saving
                    })();
                }

                let y_offset = 290;
                const canvas_rect = { x: 160, y: y_offset - 60, width: 300, height: 370 };
                ctx.fillStyle = 'rgba(200, 200, 255, 0.9)';
                ctx.fillRect(canvas_rect.x, canvas_rect.y, canvas_rect.width, canvas_rect.height);

                ctx.font = 'bold 40px sans-serif';
                ctx.fillStyle = 'rgb(50, 0, 100)';
                ctx.fillText("Leaderboard", 180, y_offset - 20);

                ctx.font = '28px sans-serif';
                ctx.fillStyle = 'rgb(10, 50, 10)';
                topScores.forEach((player, idx) => {
                    const rank = get_rank_str(idx);
                    const name = player.name;
                    const score = player.score;
                    const text = `${rank}: ${name} - ${score}`;
                    ctx.fillText(text, 180, y_offset + 30 + (idx * 30));
                });
            }

            // Draw button pad and UI elements
            draw_button_pad();
            if (gameStart) {
                scoreXY(250, 690, score_value, player_name);
                draw_buttons();
            } else {
                draw_start_button();

                // Draw input box
                ctx.fillStyle = 'rgb(200, 200, 200)';
                ctx.fillRect(input_box.x, input_box.y, input_box.width, input_box.height);
                ctx.strokeStyle = 'rgb(100, 100, 100)';
                ctx.lineWidth = 2;
                ctx.strokeRect(input_box.x, input_box.y, input_box.width, input_box.height);

                ctx.font = '40px sans-serif';
                if (player_name === "") {
                    ctx.fillStyle = 'rgb(150, 150, 150)';
                    ctx.fillText("Enter your name", input_box.x + 5, input_box.y + 45);
                } else {
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.fillText(player_name, input_box.x + 5, input_box.y + 45);
                }

                // Draw keyboard
                key_buttons.forEach(rect => {
                    ctx.fillStyle = 'rgb(180, 180, 180)';
                    ctx.beginPath();
                    ctx.roundRect(rect.x, rect.y, rect.width, rect.height, [8]);
                    ctx.fill();
                    ctx.fillStyle = 'rgb(0, 0, 0)';
                    ctx.font = '30px sans-serif';
                    ctx.fillText(rect.key, rect.x + 10, rect.y + 40);
                });
            }

            // Loop
            requestAnimationFrame(gameLoop);
        }

    </script>
</body>
</html>

